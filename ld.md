#同名全局符号覆盖（global symbol interpose）
linux下动态链接库采用如下处理方式：当一个符号需求被加入全局符号表时，如果同名符号已存在，则忽略后加入的符号。一般动态链接器的加载顺序，是按广度优先顺序进行加载，首先是main，然后是libxyz.so，然后是libc.so等。
[ref](http://pananq.com/2012/05/28/%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A0%E8%BD%BD%E4%B8%8B-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/)

#多共享动态库中同名对象(static限定的)重复析构问题
再定位完成后，动态链接器就会允许任何加载的共享程序来执行可选的初始化代码。该函数允许库来初始化内部数据并备之待用。这个代码是在上述 ELF 映像的 .init 部分中定义的。在卸载库时，它还可以调用一个终止函数（定义为映像的 .fini 部分）。当初始化函数被调用时，动态链接器会把控制权转让给加载的原始映像。

当使用选项 -fpie或 -fPIE时，生成的共享库不会为静态成员变量或全局变量在 GOT中创建对应的条目（通过 objdump或 readelf命令可以查看，此处不再赘述），从而避免了由于静态对象“构造一次，析构两次”而对同一内存区域释放两次引起的程序 core dump。

选项 -fpie和 -fPIE与 -fpic及 -fPIC的用法很相似，区别在于前者总是将生成的位置无关代码看作是属于程序本身，并直接链接进该可执行程序，而非存入全局偏移表 GOT中；这样，对于同名的静态或全局对象的访问，其构造与析构操作将保持一一对应。
[ref](https://www.ibm.com/developerworks/cn/linux/l-cn-sdlstatic/)

#非static限定全局变量
即便存在多次定义，内存中只有一份初始化的拷贝

C编译器对多重定义的全局符号的解析和链接。在编译阶段，编译器将全局符号信息隐含地编码在可重定位目标文件的符号表里。这里有个“强符号(strong)”和“弱符号(weak)”的概念——前者指的是定义并且初始化了的变量，比如foo.c里的结构体b，后者指的是未定义或者定义但未初始化的变量，比如main.c里的整型b和c，还有两个源文件都包含头文件里的a。当符号被多重定义时，GNU链接器(ld)使用以下规则决议：

不允许出现多个相同强符号。
* 如果有一个强符号和多个弱符号，则选择强符号。
* 如果有多个弱符号，那么先决议到size最大的那个，如果同样大小，则按照链接顺序选择第一个。
* 像上面这个例子中，全局变量a和b存在重复定义。如果我们将main.c中的b初始化赋值，那么就存在两个强符号而违反了规则一，编译器报错。如果满足规则二，则仅仅提出警告，实际运行时决议的是foo.c中的强符号。而变量a都是弱符号，所以只选择一个（按照目标文件链接时的顺序）。

[ref](http://coolshell.cn/articles/10115.html)