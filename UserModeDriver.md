# UIO
一个设备驱动的主要任务有两个：

1. 存取设备的内存
2. 处理设备产生的中断

对于第一个任务，UIO核心实现了mmap()可以处理物理内存(physicalmemory)，逻辑内存(logical memory)，虚拟内存(virtual memory)。UIO驱动的编写是就不需要再考虑这些繁琐的细节。

第二个任务，对于设备中断的应答必须在内核空间进行。所以在内核空间有一小部分代码用来应答中断和禁止中断，但是其余的工作全部留给用户空间处理。

如果用户空间要等待一个设备中断，它只需要简单的阻塞在对 /dev/uioX的read()操作上。当设备产生中断时，read()操作立即返回。UIO 也实现了poll()系统调用，你可以使用 select()来等待中断的发生。select()有一个超时参数可以用来实现有限时间内等待中断。
对设备的控制还可以通过/sys/class/uio下的各个文件的读写来完成。你注册的uio设备将会出现在该目录下。假如你的uio设备是uio0那么映射的设备内存文件出现在 /sys/class/uio/uio0/maps/mapX，对该文件的读写就是 对设备内存的读写。
如下的图描述了uio驱动的内核部分，用户空间部分，和uio 框架以及内核内部函数的关系。
![UIO](http://img.blog.csdn.net/20160604162113381?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

# DMA
所谓DMA，本质上就是设备访问内存。让设备访问内存，我们有如下要求：

1. 提供设备可以认知的内存地址。可以是物理地址（这个物理地址必须在设备可以访问的范围内，如果设备地址比CPU地址短，CPU就必须把地址拷贝到设备可以认知的地址内，这是Linux DMA_ZONE和Bouncing Buffer解决的问题），也可以是虚拟地址（后者需要设备有IOMMU支持，即设备可以做虚拟地址翻译）

2. 物理内存必须在位（考虑到虚拟内存可能被交换到磁盘上的情况）

3. CPU对内存的更新必须对设备可见（考虑到CPU的Cache系统和设备的Cache不一定互相认知）

无论我们在内核态做DMA还是在用户态做DMA，这三个要求都是必须的。但内核做起来比较容易，因为Linux内核可以分配“必然在位”的内存，也可以任意进行cache操作，保证CPU的更新必然对设备可见。但用户态就不一定了。

Cache问题是个死问题，要让CPU对内存的更改对设备可见，我们要不做一次系统调用（这个有软件性能成本），强刷过去。要不就让设备和CPU间实现Cache-Coherent（这个有硬件性能成本）。所以，这个没有什么可说的。

地址范围这个问题也是一样的。所以，这两个问题我更看好的思路是让硬件直接支持IOMMU和CC总线，这样这两个问题就不存在了。
![DMA](https://pic4.zhimg.com/v2-5c55a47c93b7a39872ccdf3f447f7563_b.png)